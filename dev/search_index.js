var documenterSearchIndex = {"docs":
[{"location":"#FoldingTrees.jl","page":"Home","title":"FoldingTrees.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FoldingTrees]","category":"page"},{"location":"#FoldingTrees.TreeMenu","page":"Home","title":"FoldingTrees.TreeMenu","text":"TreeMenu(root; pagesize::Int=10, dynamic = false, maxsize = pagesize, keypress = (m,i) -> false, kwargs...)\n\nUse root to create an interactive menu using TerminalMenus. pagesize is the number of lines to use for a page. If dynamic, adjust the page size based on the expansion of the content. maxsize is the maximum size of the page.\n\nProvide a function keypress to respond to keys while the menu is shown. The function has two arguments, m::TreeMenu and i::UInt32. The integer i is the key pressed. This function should return true if the menu should exit and false otherwise.\n\nkwargs are passed to TerminalMenus.Config.\n\n\n\n\n\n","category":"type"},{"location":"#FoldingTrees.count_open_leaves","page":"Home","title":"FoldingTrees.count_open_leaves","text":"count_open_leaves(node)\n\nReturn the number of unfolded descendants of node.\n\n\n\n\n\n","category":"function"},{"location":"#FoldingTrees.fold!-Tuple{Node}","page":"Home","title":"FoldingTrees.fold!","text":"fold!(node)\n\nFold the children of node. See also unfold! and toggle!.\n\n\n\n\n\n","category":"method"},{"location":"#FoldingTrees.isroot-Tuple{Node}","page":"Home","title":"FoldingTrees.isroot","text":"isroot(node)\n\nReturn true if node is the root node (meaning, it has no parent).\n\n\n\n\n\n","category":"method"},{"location":"#FoldingTrees.next","page":"Home","title":"FoldingTrees.next","text":"newnode, newdepth = next(node, depth::Int=0)\n\nReturn the next node in a depth-first search. depth counts the number of levels below the root. The parent is visited before any children.\n\n\n\n\n\n","category":"function"},{"location":"#FoldingTrees.nodes-Tuple{Node}","page":"Home","title":"FoldingTrees.nodes","text":"itr = nodes(node)\n\nCreate an iterator itr that will return the nodes, rather than the node data.\n\nExample\n\njulia> foreach(unfold!, nodes(root))\n\nwould ensure that each node in the tree is unfolded.\n\n\n\n\n\n","category":"method"},{"location":"#FoldingTrees.prev","page":"Home","title":"FoldingTrees.prev","text":"newnode, newdepth = prev(node, depth::Int=0)\n\nReturn the previous node in a depth-first search. depth counts the number of levels below the root.\n\nThis traverses in the opposite direction as next, so last, deepest children are visited before their parents.\n\n\n\n\n\n","category":"function"},{"location":"#FoldingTrees.toggle!-Tuple{Node}","page":"Home","title":"FoldingTrees.toggle!","text":"toggle!(node)\n\nChange the folding state of node. See also fold! and unfold!.\n\n\n\n\n\n","category":"method"},{"location":"#FoldingTrees.unfold!-Tuple{Node}","page":"Home","title":"FoldingTrees.unfold!","text":"unfold!(node)\n\nUnfold the children of node. See also fold! and toggle!.\n\n\n\n\n\n","category":"method"},{"location":"#FoldingTrees.writeoption-Tuple{IO, AbstractString, Int64}","page":"Home","title":"FoldingTrees.writeoption","text":"writeoption(buf::IO, data, charsused::Int; width::Int=displaysize(stdout)[2])\n\nPrint data to buf as a menu option. charsused is the number of characters already printed on that line. width allows you to specify the display width (in characters), which defaults to the width of the terminal window.\n\nGiven a tree built from Node{Data}, packages implementing a TreeMenu may need to implement writeoption(buf, data::Data, charsused).\n\nThe implementation for data::AbstractString is careful to ensure that the option does not wrap to a new line of the terminal, and to ensure that any color printing is turned off even when the line has to be truncated.\n\n\n\n\n\n","category":"method"}]
}
